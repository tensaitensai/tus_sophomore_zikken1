
\renewcommand{\thetable}{\arabic{section}.\arabic{table}}
\renewcommand{\theequation}{\arabic{section}.\arabic{subsection}.\arabic{equation}}


\vspace{7mm}
\noindent
・実習 \vspace{2mm}

図3.11のように，論理回路をパネル上で構成し，$Y = \overline{A} \cdot B + A \cdot \overline{B}$ の真理値を表示器で表示して，真理値表\ref{tbl8}と一致することを確認した．

\vspace{7mm}
\noindent
・考察 \vspace{2mm}

排他的論理和は，2つの入力のレベルが同じとき ``0'' を，異なるとき ``1'' を出力する演算であることを確かめた．排他的論理和は，様々な用途に応用されている．

実例として，まず，ビット値の反転に排他的論理和が用いられる．ある数値と，その数値の反転させたい桁のビット値を1に，それ以外の桁のビット値を0にした数値との排他的論理和をとると、指定した桁のビット値が反転した数値が得られる．例えば，${0011}_{(2)}$ の下から2ビット目と3ビット目を反転させたい場合，${0110}_{(2)}$ との排他的論理和をとることで
$$
    {0011}_{(2)} \oplus {0110}_{(2)} = {0101}_{(2)}
$$
となり，2ビット目と3ビット目が反転した値が得られる．

また，上記の性質により，排他的論理和は，2回同じ値で演算を行うと元の値が得られるという性質がある．すなわち，2つの論理変数 $A$，$B$ に対して
\begin{equation}
    (A \oplus B) \oplus B = A \label{eq01}
\end{equation}
が成り立つ．このことは次に示す真理値表\ref{tbl01}で確かめることができる．

\begin{table}[!h]
    \caption{$Y = (A \oplus B) \oplus B$ の真理値表}
    \label{tbl01}
    \begin{center}
        \begin{tabular}{|c|c||c|c|}
            \hline
            $A$ & $B$ & $A \oplus B$ & Y \\
            \hhline{|=|=#=|=|}
            0   & 0   & 0            & 0 \\
            \hline
            0   & 1   & 1            & 0 \\
            \hline
            1   & 0   & 1            & 1 \\
            \hline
            1   & 1   & 0            & 1 \\
            \hline
        \end{tabular}
    \end{center}
\end{table}
上の真理値表で，$A$ と $Y$ は真理値が一致しており，確かに $Y = A$ となっている．この性質は非常に重要であり，多くの応用例がある．

例えば，プログラミングにおいて排他的論理和を用いると，一時変数を用いずに変数の値の交換することができる．すなわち，$X \oplus Y = Z$ とすると $X \oplus Z = Y$，$Y \oplus Z = X$ であることを利用すると，
\begin{center}
    \begin{verbatim}
                               {
                                   ...
                                   x = x ^ y;
                                   y = x ^ y;
                                   x = x ^ y;
                                   ...
                               }
    \end{verbatim}
\end{center}
のようにプログラムを組むことで，値の交換が可能となる．ここで \textasciicircum$\:$は排他的論理和を表す演算子である．この方法は，一時変数を用いないため，メモリの節約につながる．

また，式(\ref{eq01})の性質を用いると，暗号鍵と復号鍵が同一な暗号を作成することができる．平文を $P$，鍵を $K$ とすると，
$$
    (P \oplus K) \oplus K = P
$$
となることから，平文と同じ長さのビット列を鍵として用意することで，暗号化と復号に同一の鍵を用いることができる．このような暗号はバーナム暗号と呼ばれる．

\subsubsection*{(8) 加算器(ADDER)}
\noindent
・目的 \vspace{2mm}

\begin{enumerate}
    \item 加算器の $S$ の部分が排他的論理和(Exclusive-OR)であることを理解する．
    \item 半加算器の動作を理解する．
\end{enumerate}

\vspace{7mm}
\noindent
・理論 \vspace{2mm}

加算器には，下位からの桁上げを考慮しない半加算器(Half-ADDER)と，下位からの桁上げを考慮する全加算器(Full-ADDER)とがある．全加算器は，半加算器を2個，OR回路を1個直列に接続した形になる．

半加算器の論理式は，次の式で与えられる．
\begin{eqnarray}
    S &=& \overline{A} \cdot B + A \cdot \overline{B} \; (= A \oplus B) \label{eq9} \\
    C &=& A \cdot B \label{eq10}
\end{eqnarray}
この論理式を論理回路に置き換えると図3.12になる．また，式(\ref{eq9})から分かるように，回路の和(Sum)を構成している部分は，Exclusive-ORになる．

全加算器の論理式は，次の式で与えられる．
\begin{eqnarray}
    S &=& \overline{A} \cdot \overline{B} \cdot C_i + \overline{A} \cdot B \cdot \overline{C_i} + A \cdot \overline{B} \cdot \overline{C_i} + A \cdot B \cdot C_i \label{eq11} \\
    C_O &=& \overline{A} \cdot B \cdot C_i + A \cdot \overline{B} \cdot C_i + A \cdot B \cdot \overline{C_i} + A \cdot B \cdot C_i \nonumber \\
    &=& A \cdot B + B \cdot C_i + A \cdot C_i \label{eq12}
\end{eqnarray}
いま，$S_1 = \overline{A} \cdot B + A \cdot \overline{B}$ とすれば，
\begin{equation}
    S = \overline{S_1} \cdot C_i + S_1 \cdot \overline{C_i} \label{eq13}
\end{equation}
また，$C_1 = A \cdot B$，$C_2 = S_1 \cdot C_i$ とすれば，
\begin{eqnarray}
    C_O &=& C_1 + C_2 \nonumber \\
    &=& A \cdot B + S_1 \cdot C_i \label{eq14}
\end{eqnarray}
となり，さらに，Exclusive-ORを用いて表せば，
\begin{eqnarray}
    S &=& A \oplus B \oplus C \label{eq15} \\
    C_O &=& A \cdot B + (A \oplus B) \cdot C_i \label{eq16}
\end{eqnarray}
となる．この論理式を論理回路に置き換えると図3.13になる．

\begin{table}[!h]
    \caption{Half-ADDERの真理値表}
    \label{tbl9}
    \begin{center}
        \begin{tabular}{|c|c||c|c|}
            \hline
            $A$ & $B$ & $C$ & $S$ \\
            \hhline{|=|=#=|=|}
            0   & 0   & 0   & 0   \\
            \hline
            0   & 1   & 0   & 1   \\
            \hline
            1   & 0   & 0   & 1   \\
            \hline
            1   & 1   & 1   & 0   \\
            \hline
        \end{tabular}
    \end{center}
\end{table}

\newpage
\begin{table}[!h]
    \caption{Full-ADDERの真理値表}
    \label{tbl10}
    \begin{center}
        \begin{tabular}{|c|c|c||c|c|}
            \hline
            $A$ & $B$ & $C_i$ & $C_O$ & $S$ \\
            \hhline{|=|=|=#=|=|}
            0   & 0   & 0     & 0     & 0   \\
            \hline
            0   & 0   & 1     & 0     & 1   \\
            \hline
            0   & 1   & 0     & 0     & 1   \\
            \hline
            0   & 1   & 1     & 1     & 0   \\
            \hline
            1   & 0   & 0     & 0     & 1   \\
            \hline
            1   & 0   & 1     & 1     & 0   \\
            \hline
            1   & 1   & 0     & 1     & 0   \\
            \hline
            1   & 1   & 1     & 1     & 1   \\
            \hline
        \end{tabular}
    \end{center}
\end{table}

\vspace{7mm}
\noindent
・実習 \vspace{2mm}

図3.12，3.13の論理回路を図3.14，3.15，3.16，3.17のようにパネル上で構成し，各真理値を表示器で表示して，真理値表\ref{tbl9}，\ref{tbl10}と一致することを確認した．

\vspace{7mm}
\noindent
・考察 \vspace{2mm}
半加算器は，下位からの桁上げを考慮せずに1ビット値の加算を行う回路であるが，これを2つ組み合わせることにより，下位からの桁上げも考慮して1ビット値の加算を行う全加算器を構成することができることが分かった．1ビットにつき1つの全加算器が必要であるから，$n$ ビット同士の加算を行うためには，$n$ 個分の全加算器を用意すればよいことが分かる．なお，整数値の範囲では，LSBについては下位からの桁上げを考慮する必要がないため，LSBの演算にのみ，半加算器を用いてもよい．このとき，回路は，1個の半加算器と $n - 1$ 個の全加算器で構成されることになる．一方，LSBの加算にも全加算器を用いる場合は，その全加算器への入力 $C_O$ が常に ``0'' となるようアースすることになる．

加算器は，他の四則演算を行う回路，すなわち，減算回路，乗算回路，除算回路においても用いられるなど，非常に重要な演算回路である．

\subsubsection*{(9) デコーダ(DECODER)}
\noindent
・目的 \vspace{2mm}

2進数を10進数に変換する動作を理解する．

\vspace{7mm}
\noindent
・理論 \vspace{2mm}

4ビットの2進数コードを、もとの10進数に戻すようなコード翻訳動作をする論理回路を、デコーダといい、2進数と10進数の関係性は次のようになる．

\newpage
\begin{center}
    2進数コード:
    $A = 2^0$ ビット，$B = 2^1$ ビット \\
    $\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;$ $C = 2^2$ビット，$D = 2^3$ビット　\\
    10進数: $\;\;\;\;\;\;\;$ ``0'' $\sim$ ``9'' として $\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;$ \\
    $\;\:$ ``0'' $= \overline{A} \cdot \overline{B} \cdot \overline{C} \cdot \overline{D}$\\
    $\;\:$ ``1'' $= A \cdot \overline{B} \cdot \overline{C} \cdot \overline{D}$ \\
    $\;\:$ ``2'' $= \overline{A} \cdot B \cdot \overline{C} \cdot \overline{D}$ \\
    $\;\:$ ``3'' $= A \cdot B \cdot \overline{C} \cdot \overline{D}$ \\
    $\;\:$ ``4'' $= \overline{A} \cdot \overline{B} \cdot C \cdot \overline{D}$ \\
    $\;\:$ ``5'' $= A \cdot \overline{B} \cdot C \cdot \overline{D}$ \\
    $\;\:$ ``6'' $= \overline{A} \cdot B \cdot C \cdot \overline{D}$ \\
    $\;\:$ ``7'' $= A \cdot B \cdot C \cdot \overline{D}$ \\
    $\;\:$ ``8'' $= \overline{A} \cdot \overline{B} \cdot \overline{C} \cdot D$ \\
    $\;\:$ ``9'' $= A \cdot \overline{B} \cdot \overline{C} \cdot D$
\end{center}
\vspace{3mm}
この式を満足する論理回路，及び真理値表を図3.18，及び表\ref{tbl11}に示す．

\begin{table}[!h]
    \caption{デコーダ(2進数と10進数)の真理値表}
    \label{tbl11}
    \begin{center}
        \begin{tabular}{|c||c|c|c|c||c|c|c|c|c|c|c|c|c|c|}
            \hline
              & \multicolumn{4}{|c|}{2進数} & \multicolumn{10}{|c|}{10進数}                                                                                             \\ \hline
              & $A$                         & $B$                           & $C$ & $D$ & ``0'' & ``1'' & ``2'' & ``3'' & ``4'' & ``5'' & ``6'' & ``7'' & ``8'' & ``9'' \\
            \hhline{|=#=|=|=|=#=|=|=|=|=|=|=|=|=|=|}
            0 & 0                           & 0                             & 0   & 0   & 1     & 0     & 0     & 0     & 0     & 0     & 0     & 0     & 0     & 0     \\ \hline
            1 & 0                           & 0                             & 0   & 1   & 0     & 1     & 0     & 0     & 0     & 0     & 0     & 0     & 0     & 0     \\ \hline
            2 & 0                           & 0                             & 0   & 1   & 0     & 0     & 1     & 0     & 0     & 0     & 0     & 0     & 0     & 0     \\ \hline
            3 & 0                           & 0                             & 0   & 1   & 0     & 0     & 0     & 1     & 0     & 0     & 0     & 0     & 0     & 0     \\ \hline
            4 & 0                           & 1                             & 0   & 0   & 0     & 0     & 0     & 0     & 1     & 0     & 0     & 0     & 0     & 0     \\ \hline
            5 & 0                           & 1                             & 0   & 1   & 0     & 0     & 0     & 0     & 0     & 1     & 0     & 0     & 0     & 0     \\ \hline
            6 & 0                           & 1                             & 1   & 0   & 0     & 0     & 0     & 0     & 0     & 0     & 1     & 0     & 0     & 0     \\ \hline
            7 & 0                           & 1                             & 1   & 1   & 0     & 0     & 0     & 0     & 0     & 0     & 0     & 1     & 0     & 0     \\ \hline
            8 & 1                           & 0                             & 0   & 0   & 0     & 0     & 0     & 0     & 0     & 0     & 0     & 0     & 1     & 0     \\ \hline
            9 & 1                           & 0                             & 0   & 1   & 0     & 0     & 0     & 0     & 0     & 0     & 0     & 0     & 0     & 1     \\ \hline
        \end{tabular}
    \end{center}
\end{table}

\vspace{7mm}
\noindent
・実習 \vspace{2mm}

パネル上のデコーダ部分を使用し，図3.19のように論理回路を構成して，各真理値を表示器で表示し，真理値表\ref{tbl11}と一致することを確認した．

\vspace{7mm}
\noindent
・考察 \vspace{2mm}

10進数 0 $\sim$ 9 それぞれを4ビットの2進数で表すことにより，特定の1つの4ビット入力に対してのみ ``1'' を出力し，0 $\sim$ 9 のうちただ1つだけを表示することができる．このような表示法は2進化10進法(Binary Coded Decimal:BCD)と呼ばれる．

デコーダは復号器とも呼ばれ，エンコーダ(符号器)とともに用いられることが多い．また，10進数だけでなく，8進数や16進数と2進数との相互変換を行うエンコーダやデコーダを構成することも可能であると考えられる．8進数の場合，デコーダは3入力8出力となる．

\subsubsection*{・順序回路 [実験(10)，(11)]}

順序回路(Sequential Circuit)は，出力が入力だけでなく回路そのものの状態によって左右される論理回路で，R-Sフリップ・フロップ回路(R-S Flip$\cdot$Flop Circuit)，J-Kフリップ・フロップ回路(J-K Flip$\cdot$Flop Circuit)，シフトレジスタ(Shift Register)などがあり，その応用として $n$ 進カウンタや，$n$ ビットのシフトレジスタがある．

\subsubsection*{(10) R-Sフリップ・フロップ回路}
\noindent
・目的 \vspace{2mm}

\begin{enumerate}
    \item R-Sフリップ・フロップ回路が１ビットの記憶素子であることを理解する．
    \item R-S フリップ・フロップ回路において禁止とされる入力が存在することを理解する．
\end{enumerate}

\vspace{7mm}
\noindent
・理論 \vspace{2mm}

R-Sフリップ・フロップ回路は，``0''，または ``1'' の論理レベルを記録する機能を持った回路である．論理式，シンボル，回路，真理値表は各々式(\ref{eq17})，(\ref{eq18})，図3.20(a)，図3.20(b)，表\ref{tbl12}で表現される．
\begin{eqnarray}
    Q^{(n+1)}=\overline{\overline{S^{(n)}} \cdot {\overline{Q}}^{(n)}} \label{eq17} \\
    {\overline{Q}}^{(n+1)}=\overline{\overline{R^{(n)}} \cdot Q^{(n)}} \label{eq18}
\end{eqnarray}
ただし時刻 $n$ に関して，$S^{(n)}$，$R^{(n)}$，及び $Q^{(n)}$，${\overline{Q}}^{(n)}$ は図3.20における入力 $S$，$R$ と出力 $Q$，$\overline{Q}$ を表すものとする．

動作は，$Q$ と $\overline{Q}$ が相補の関係($Q$ と $\overline{Q}$ が互いに異なる値をもつ)にあるとき，$R$ と $S$ が ``0'' レベルの時，出力は元の状態を保持し，$S$ が ``1''，$R$ が ``0'' なら出力 $Q$ は ``1''，$S$ が ``0''，$R$ が ``1'' なら出力 $Q$ は ``0'' にそれぞれ落ち着く．
しかしながら $S$ と $R$ がともに ``1'' の場合は $Q$ と $\overline{Q}$ が ``0'' と ``1'' のレベルを相互に繰り返すこととなる(ただし，実際には図3.20(b)の各NAND素子の応答速度の差異や配線の長さによって，$Q$ と $\overline{Q}$ が相補になるように落ち着く)．このため，R-Sフリップ・フロップ回路では，$S$ と$R$ を共に ``1'' として入力することを ``禁止'' としている場合が多い．

\begin{table}[!h]
    \caption{R-Sフリップ・フロップ回路の真理値表}
    \label{tbl12}
    \begin{center}
        \begin{tabular}{|c|c|c|c||c|}
            \hline
            $S^{(n)}$ & $R{(n)}$ & $Q^{(n+1)}$ & ${\overline{Q}}^{(n+1)}$ &      \\
            \hhline{|=|=|=|=#=|}
            0         & 0        & $Q^{(n)}$   & ${\overline{Q}}^{(n)}$   &      \\
            \hline
            0         & 1        & 0           & 1                        &      \\
            \hline
            1         & 0        & 1           & 1                        &      \\
            \hline
            1         & 1        & 1           & 0                        & 禁止 \\
            \hline
        \end{tabular}
    \end{center}
\end{table}

\newpage
\noindent
・実習 \vspace{2mm}

図3.21のように，パネル上のR-Sフリップ・フロップの素子を使用し，$S$，$R$ の入力レベルに対する出力レベル $Q$，$\overline{Q}$ のレベルを表示器で確認した．

\vspace{7mm}
\noindent
・考察 \vspace{2mm}

禁止入力を行ったときの各ビットの状態の遷移について考察する．
まず，$(S,\; R) = (0,\; 0),\; (0,\; 1), (1,\; 0)$ の順に入力すると，図3.A(a)(b)(c)のように，NANDゲート素子G1，G2のどちらが先に開いても，$Q$ と $\overline{Q}$ は1つの相補状態で安定する．その後 $(S,\; R) = (1,\; 1)$ を入力すると，図3.A(d)のように $Q = 1,\; \overline{Q} = 1$  となり相補関係が満たされなくなるが，出力は1種類で安定している．しかし次に同時に $(S,\; R) = (0,\; 0)$ を入力すると，G1が先に開いた場合は $Q = 0,\; \overline{Q} = 1$，
G2が先に開いた場合は $Q = 1,\; \overline{Q} = 0$ となり，どちらのゲートが先に開くかによって $Q$ と $\overline{Q}$ の値が変わって，出力が不定となってしまう(図3.A(e)(f))．すなわち，本来値を保持するはずの入力 $(S,\; R) = (0,\; 0)$ を行っているにも関わらず，値が変わってしまう．そこで，$(S,\; R) = (1,\; 1)$ を禁止入力とすることで，値の記憶機能を保っているのである．

\subsubsection*{(11) J-Kフリップ・フロップ回路}
\noindent
・目的 \vspace{2mm}

\begin{enumerate}
    \item J-Kフリップ・フロップがトリガ型フリップ・フロップ回路であることを理解する．
    \item J，Kをともに ``1'' としたときには，Tフリップ・フロップにもなることを理解する．
\end{enumerate}

\vspace{7mm}
\noindent
・理論 \vspace{2mm}

R-Sフリップ・フロップ回路は，$R$，$S$ のレベルが直接出力を決定するのに対して，J-Kフリップ・フロップ回路は，$J$ と $K$ のレベルの他に，トリガが加えられないと，出力が決定されない，トリガ型のフリップ・フロップ回路の一種である．

論理式，回路，真理値表は，各々式(\ref{eq19})，(\ref{eq20})，図3.22(a)，表\ref{tbl13}で表される．
\begin{eqnarray}
    Q^{(n+1)} &=& \overline{K^{(n)}} \cdot Q^{(n)} + J^{(n)} \cdot {\overline{Q}}^{(n)} \label{eq19} \\
    {\overline{Q}}^{(n+1)} &=& \overline{Q^{(n+1)}} \label{eq20}
\end{eqnarray}
動作は次のようになる．
\begin{enumerate}
    \item $J$ と $K$ が ``0'' レベルのときの出力 $Q$ は，トリガパルス $T$ が加えられても元の状態を保持する．
    \item $J$ が ``1''，$K$ が ``0'' のときの出力 $Q$ は，トリガパルス $T$ が加えられると ``1'' になり，この状態でさらにトリガパルスが加えられても、元の状態(``1'')を保持する．
    \item $J$ が ``0''，$K$ が ``1'' のときの出力$Q$は，トリガパルス $T$ が加えられると ``0'' となり，この状態でさらにトリガパルスが加えられても、元の状態(``0'')を保持する．
    \item $J$ と $K$ が ``0'' レベルのときの出力 $Q$ はトリガパルス $T$ が加えられるごとにレベルが反転する．(Tフリップ・フロップ:トグルフリップ・フロップ)
    \item $PC$ を ``0'' にすると，$J$，$K$，$T$ のレベルに関係なく，出力 $Q$ は ``0'' になる．(Pre-Clear)
\end{enumerate}

なお，トリガパルス入力端子(図3.22(a)における $T$ と書かれた端子)の先端は否定回路同様に ``〇'' と書かれるが，これはトリガパルスの電圧下降部でトリガされることを意味する．

\vspace{0.5cm}

\begin{table}[!h]
    \caption{J-Kフリップ・フロップ回路の真理値表}
    \label{tbl13}
    \begin{center}
        \begin{tabular}{cc}
            \begin{minipage}{0.6\hsize}
                \begin{center}
                    \begin{tabular}{|c|c|c|c|c||c|}
                        \hline
                        $J^{(n)}$ & $K^{(n)}$ & $T$          & $Q^{(n+1)}$            & ${\overline{Q}}^{(n + 1)}$ & 動作     \\
                        \hhline{|=|=|=|=|=#=|}
                        0         & 0         & $\downarrow$ & $Q^{(n)}$              & $ {\overline{Q}}^{(n)}$    & ホールド \\
                        \hline
                        0         & 1         & $\downarrow$ & 0                      & 1                          & リセット \\
                        \hline
                        1         & 0         & $\downarrow$ & 1                      & 0                          & セット   \\
                        \hline
                        1         & 1         & $\downarrow$ & ${\overline{Q}}^{(n)}$ & $Q^{(n)}$                  & トグル   \\
                        \hline
                    \end{tabular}
                \end{center}
            \end{minipage}
            \begin{minipage}{0.4\hsize}
                \begin{center}
                    \begin{tabular}{|c|c|}
                        \hline
                        $PC$ & $Q^{(n + 1)}$ \\
                        \hhline{|=#=|}
                        0    & 0             \\
                        \hline
                        1    & $Q^{(n)}$     \\
                        \hline
                    \end{tabular}
                \end{center}
            \end{minipage}
        \end{tabular}
    \end{center}
\end{table}

\vspace{7mm}
\noindent
・実習 \vspace{2mm}

図3.23のように，パネル上のJ-Kフリップ・フロップの素子を使用し，$J$，$K$ の入力に対してトリガパルスを加えたときの出力 $Q$，$\overline{Q}$ のレベルを表示器で確認した．

トリガパルスには，パネル上のパルス発生器から手動による単発パルスを用いた．また，$PC$ 端子には，同じパルス発生器のクロックパルスを使用した．

\vspace{7mm}
\noindent
・考察 \vspace{2mm}

J-K フリップ・フロップは，R-Sフリップ・フロップとは異なり，禁止入力がないため，扱いやすい記憶素子であると考えられる．


また，J-Kフリップ・フロップ回路は，トリガパルスを用いることで，出力のタイミングを自由に決めることができるという利点がある．この性質を用いると，0 から $N-1$ までカウントし
，カウントが $N$ になった時点でカウントを0にリセットする $N$ 進アップカウンタをつくることができる．J-Kフリップ・フロップ回路ではトリガパルスの電圧下降時にトリガされることから，下位からの桁上げを下位ビットの $1 \rightarrow 0$ の反転(すなわち，下位ビットの電圧降下)により検知し，その電圧降下をトリガとして用いることによって自分のビットを反転させる．これにより，10進で1カウントアップすることができる．また，各ビットの出力を並べた値が $N_{(10)}$ に対応する2進数に達した瞬間にだけ出力が ``1'' となる回路を構成し，その出力をすべてのJ-Kフリップ・フロップの $PC$ に用いることで値を ``0'' にリセットすることができる．このようにして $N$ 進カウンタをつくることができる．
\newpage
\subsection{NAND回路による組み合わせ回路の構成}

組み合わせ回路は全てNAND回路で構成できることを示す．基本素子 AND，OR，NOT，NORがNANDのみで構成できることが分かれば十分であるから，これを例を挙げながら示していくことにする．なお，NANDの真理値表は表\ref{tbl4}の通りである．

\vspace{7mm}
\noindent
(1) NOT回路 \vspace{2mm}

図3.B(a)のように，NAND素子に同一の ``A'' 2つを入力することにより，次の真理値表\ref{tbl01}が得られ，$\overline{A} = \overline{A \cdot A}$であることが分かる．したがって，NOT回路はNAND素子1つで実現することができる．実際，$X = X + X$ が成り立つこととド・モルガンの定理を用いれば，
$$
    \overline{A \cdot A} = \overline{A} + \overline{A} = \overline{A}
$$
となる．

\begin{table}[!h]
    \caption{$\overline{A},\;\overline{A \cdot A}$ の真理値表}
    \label{tbl01}
    \begin{center}
        \begin{tabular}{|c|c||c|c|}
            \hline
            $A$ & $A$ & $\overline{A}$ & $\overline{A \cdot A}$ \\
            \hhline{|=|=#=|=|}
            0   & 0   & 1              & 1                      \\
            \hline
            1   & 1   & 0              & 0                      \\
            \hline
        \end{tabular}
    \end{center}
\end{table}

\vspace{7mm}
\noindent
(2) AND回路 \vspace{2mm}

$A \cdot B = \overline{\overline{A \cdot B}}$ であることを用いれば，NAND素子の出力 $Y_1 = \overline{A \cdot B}$ をNOT素子に入力することで，AND回路を構成することができる．したがって，(1)を考慮すると，図3.B(b)のようにNAND回路を2つ用いて論理回路を構成すればよい．

\begin{table}[!h]
    \caption{$A \cdot B,\; \overline{\overline{A \cdot B}}$ の真理値表}
    \label{tbl02}
    \begin{center}
        \begin{tabular}{|c|c||c|c|c|}
            \hline
            $A$ & $B$ & $A \cdot B$ & $Y_1 = \overline{A \cdot B}$ & $\overline{Y_1}$ \\
            \hhline{|=|=#=|=|=|}
            0   & 0   & 0           & 1                            & 0                \\
            \hline
            0   & 1   & 0           & 1                            & 0                \\
            \hline
            1   & 0   & 0           & 1                            & 0                \\
            \hline
            1   & 1   & 1           & 0                            & 1                \\
            \hline
        \end{tabular}
    \end{center}
\end{table}

\vspace{7mm}
\noindent
(3) OR回路 \vspace{2mm}

ド・モルガンの定理より，$A + B = \overline{\overline{A + B}} = \overline{\overline{A} \cdot \overline{B}}$ であることを用いれば，入力 $A$，$B$ をNOT素子に入力し，その出力をNAND素子に入力することでOR回路を構成することができる．具体的には，(1)を考慮して，図3.B(c)のようにNAND回路を3つ用いて論理回路を構成すればよい．

\newpage
\begin{table}[!h]
    \caption{$A + B,\; \overline{\overline{A} \cdot \overline{B}}$ の真理値表}
    \label{tbl03}
    \begin{center}
        \begin{tabular}{|c|c||c|c|c|c|c|}
            \hline
            $A$ & $B$ & $A + B$ & $\overline{A}$ & $\overline{B}$ & $\overline{A} \cdot \overline{B}$ & $\overline{\overline{A} \cdot \overline{B}}$ \\
            \hhline{|=|=#=|=|=|=|=|}
            0   & 0   & 0       & 1              & 1              & 1                                 & 0                                            \\
            \hline
            0   & 1   & 1       & 1              & 0              & 0                                 & 1                                            \\
            \hline
            1   & 0   & 1       & 0              & 1              & 0                                 & 1                                            \\
            \hline
            1   & 1   & 1       & 0              & 0              & 0                                 & 1                                            \\
            \hline
        \end{tabular}
    \end{center}
\end{table}

\vspace{7mm}
\noindent
(4) NOR回路 \vspace{2mm}

(3)で構成したOR回路の出力を(1)で構成したNOT素子に入力することで，NOR回路を構成することができる．具体的には，図3.B(d)のようにNAND素子を4つ用いて論理回路を構成すればよい．

\vspace{7mm}

以上により，基本素子がすべてNAND素子のみで構成可能であることが分かった．これにより，基本素子で構成されるすべての組み合わせ回路についても，NAND素子のみで構成可能であることが示された．

\subsection{2値論理における減算の理論}

減算を行う回路には，加算と同様に，半減算器と全減算器がある．
2値論理における減算には図3.C(a)に示すような4つの基本演算がある．$0 - 1$ のときはその桁から引けないので，1つ上の桁から1を借りるという操作が必要である．$D = A - B$，及び桁借り $B_O$ として，半減算器のシンボルと真理値表はそれぞれ，図3.C(a)，表\ref{tbl04}のようになる．

\begin{table}[!h]
    \caption{半減算器の真理値表}
    \label{tbl04}
    \begin{center}
        \begin{tabular}{|c|c||c|c|}
            \hline
            $A$ & $B$ & $B_O$ & $D$ \\
            \hhline{|=|=#=|=|}
            0   & 0   & 0     & 0   \\
            \hline
            0   & 1   & 1     & 1   \\
            \hline
            1   & 0   & 0     & 1   \\
            \hline
            1   & 1   & 0     & 0   \\
            \hline
        \end{tabular}
    \end{center}
\end{table}

真理値表から図3.C(c)(d)のような半減算回路が構成できる．また，加算と同様，半減算回路を2つ用いることで，桁借りを考慮した全減算回路を作ることができる(図3.D)．

また，$A - B = A + (-B)$ であることを利用して，補数表示した2つの数値を加算するという方法で減算を実現することも可能である．

\newpage
\subsection{同期・非同期カウンタの回路と動作原理}

非同期式4進カウンタと同期式4進カウンタの回路を図3.Eに示した．これらのカウンタは，$Q_1 Q_0 = \in \{ 00, 01, 10, 11 \}$ の値をクロックパルスが与えられるごとにカウントアップする回路である．非同期カウンタでは，$Q_0$ の値が $1 \rightarrow 0$ に下がったときに $Q_1$ の値が反転することを利用し，$Q_0$ を2桁目の加算のクロックに用いている．一方同期カウンタでは，$Q_0, Q_1$ ともに同一のクロックパルスを用い，また $J_1$，$K_1$ に $Q_0$ を入力することにより $Q_0$，$Q_1$ に対して演算を行っている．

\section{結論}

本実験では，論理回路の基本的な素子の動作とその応用を理解した．とりわけ，加減算回路などは計算機設計などでは欠かせない分野であり，さらに理解を深める必要があると思われる．

\begin{thebibliography}{9}
    \bibitem{bib1} 東京理科大学工学部情報工学科 (2017) 『情報工学実験1:平成29年度』
    \bibitem{bib2} 大類重範 (2010-2017) 『ディジタル電子回路』 日本理工出版会
    \bibitem{bib3} 松本洋平 『情報処理基礎論』 [online]\underline{http://www2.kaiyodai.ac.jp/~matumoto/lecture02/}
    2017年5月28日最終閲覧
    \bibitem{bib4} ``Camp Network'' $\;$   [online]\underline{http://capm-network.com/} $\;$ 2017年5月28日最終閲覧
    \bibitem{bib5} 『エンコーダとデコーダ』$\;$ [online]\underline{http://home.a00.itscom.net/hatada/dc2/chap15/decoder.html} $\;\;$ 2017年5月28日最終閲覧
    \bibitem{bib6} 『RSフリップフロップの禁止(不定)について』\\ $\;$  [online]\underline{http://shusaku721-bibou6.seesaa.net/article/441811548.html} $\;$ 2017年5月28日最終閲覧
\end{thebibliography}

\end{document}

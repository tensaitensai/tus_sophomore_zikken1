\documentclass[a4paper,12pt]{jsarticle}
\usepackage{dcolumn} %%小数点をそろえる
\usepackage{longtable} %%複数ページにまたがる表
\usepackage{multirow} %%表の縦結合
\usepackage{amsmath} %%数式用パッケージ
\usepackage{amssymb} %%数式用パッケージ
\usepackage{fancybox} %%枠付きの文章
\usepackage{listings,jlisting} %%リスティングの導入
\usepackage{here} %%強制出力
\usepackage{moreverb} %%プログラムコードを載せる
\usepackage{caption} %%図・表のカスタマイズ
\newcolumntype{d}[1]{D{.}{.}{#1}}
\setlength{\textwidth}{170mm}
\setlength{\textheight}{260mm}
\setlength{\oddsidemargin}{-5mm}
\setlength{\topmargin}{-25mm}
\newcommand{\R}{\mbox{\boldmath$R$}}
\usepackage[dvipdfmx]{graphicx}
\usepackage[top=30truemm,bottom=30truemm,left=25truemm,right=25truemm]{geometry}
\lstset{
language = {c},
basicstyle={\footnotesize\ttfamily}, %書体の指定
identifierstyle={\footnotesize},%
commentstyle={\footnotesize\ttfamily},%
keywordstyle={\footnotesize\ttfamily},%
ndkeywordstyle={\footnotesize},%
stringstyle={\footnotesize\ttfamily},
frame=tRBl, %フレームの指定
framesep=25pt, %フレームと中身（コード）の間隔
breaklines=false, %行が長くなった場合の改行
linewidth=16.7cm, %フレームの横幅
lineskip=-0.5ex, %行間の調整
numbers=left,%プログラムソースの行番号の位置 stepnumber=1,%stepnumberで設定した値おきに行番号が表示されます
numberstyle=\scriptsize,%行番号の文字サイズ
tabsize=3 %Tabを何文字幅にするかの指定
}

\begin{document}

\lstset{language=pascal,
  basicstyle=\ttfamily,
  columns=[l]{fullflexible}
}

\section{実験結果}
\subsection{ソースコード}
実験で作成したソースコードを示す．\\

\lstinputlisting[basicstyle=\footnotesize,caption=read\_2\_1byte.c,label=read2_1byte]{read_2_1byte.c}
\lstinputlisting[basicstyle=\footnotesize,caption=read\_2\_1byte\_prob1\_2.c,label=read2_1byte_prob1_2]{read_2_1byte_prob1_2.c}
\lstinputlisting[basicstyle=\footnotesize,caption=read\_3\_fgetc.c,label=read3_fgetc]{read_3_fgetc.c}
\lstinputlisting[basicstyle=\footnotesize,caption=read\_2\_2048byte\_prob2\_2.c,label=read2_2048byte_prob2_2]{read_2_2048byte_prob2_2.c}
\lstinputlisting[basicstyle=\footnotesize,caption=read\_3\_fgets\_prob2\_3.c,label=read3_fgets_prob2_3]{read_3_fgets_prob2_3.c}
\lstinputlisting[basicstyle=\footnotesize,caption=read\_3\_wcl\_prob2\_5.c,label=read_3_wcl_prob2_5]{read_3_wcl_prob2_5.c}
\lstinputlisting[basicstyle=\footnotesize,caption=fork\_2\_1.c,label=fork2_1]{fork_2_1.c}
\lstinputlisting[basicstyle=\footnotesize,caption=fork\_2\_1\_prob3\_1.c,label=fork_2_1_prob3_1]{fork_2_1_prob3_1.c}
\lstinputlisting[basicstyle=\footnotesize,caption=fork\_2\_1\_prob3\_2.c,label=fork_2_1_prob3_2]{fork_2_1_prob3_2.c}
\lstinputlisting[basicstyle=\footnotesize,caption=fork\_2\_1\_prob3\_3.c,label=fork_2_1_prob3_3]{fork_2_1_prob3_3.c}
\lstinputlisting[basicstyle=\footnotesize,caption=fork\_2\_1\_prob3\_5.c,label=fork_2_1_prob3_5]{fork_2_1_prob3_5.c}
\lstinputlisting[basicstyle=\footnotesize,caption=execl.c,label=execl]{execl.c}
\lstinputlisting[basicstyle=\footnotesize,caption=execv.c,label=execv]{execv.c}
\lstinputlisting[basicstyle=\footnotesize,caption=execvp.c,label=execvp]{execvp.c}
\lstinputlisting[basicstyle=\footnotesize,caption=execl\_ls.c,label=exec_lsl]{execl_ls.c}
\lstinputlisting[basicstyle=\footnotesize,caption=prob4-4.c,label=prob4-4]{prob4-4.c}
\lstinputlisting[basicstyle=\footnotesize,caption=prob5-1.c,label=prob5-1]{prob5-1.c}
\lstinputlisting[basicstyle=\footnotesize,caption=prob5-2.c,label=prob5-2]{prob5-2.c}
\lstinputlisting[basicstyle=\footnotesize,caption=prob5-3.c,label=prob5-3]{prob5-3.c}
\lstinputlisting[basicstyle=\footnotesize,caption=prob5-4.c,label=prob5-4]{prob5-4.c}
\lstinputlisting[basicstyle=\footnotesize,caption=prob5-5.c,label=prob5-5]{prob5-5.c}
\lstinputlisting[basicstyle=\footnotesize,caption=prob5-6.c,label=prob5-6]{prob5-6.c}
\lstinputlisting[basicstyle=\footnotesize,caption=prob5-9.c,label=prob5-9]{prob5-9.c}
\lstinputlisting[basicstyle=\footnotesize,caption=prob5-10.c,label=prob5-10]{prob5-10.c}



\subsection{結果}
\subsubsection{演習1・演習2}
問題2-1・問題2-2・問題2-3において，ファイルサイズの処理時間を計測した．時間の計測では，以下のようにtime関数を用いた．
\begin{table}[H]
  \begin{center}
    \begin{tabular}{|p{150mm}|}
      \hline
      \verb|$|  time  ./(file name)  (read file)\verb|>| /dev/null \\
      \hline
    \end{tabular}
  \end{center}
\end{table}
\vspace{-2zh}

(file name)には，作成したプログラム名，(read file)には，読み込むテキストファイルの名前が入る．今回読み込んだファイルの名前はsample\_*.txtであり，*に書いてある数字の数の文字が記録されている．\\
\fbox{問題2-1}\\
NBUFが1の時(ソースコード1)・ソースコード3の実行．
\begin{lstlisting}[basicstyle=\footnotesize, caption={time\_read\_2\_1byte}, label=read1byte]
$ time ./read_2_1byte sample_10.txt > /dev/null
real	0m0.007s
user	0m0.001s
sys	0m0.002s

$ time ./read_2_1byte sample_100.txt > /dev/null
real	0m0.006s
user	0m0.001s
sys	0m0.002s

$ time ./read_2_1byte sample_1000000.txt > /dev/null
real	0m0.894s
user	0m0.173s
sys	0m0.710s

$ time ./read_2_1byte sample_10000000.txt > /dev/null
real	0m8.781s
user	0m1.695s
sys	0m7.066s
\end{lstlisting}


\begin{lstlisting}[basicstyle=\footnotesize,caption={time\_read\_3\_fgetc}, label=readfgetc]
$ time ./read_3_fgetc sample_10.txt > /dev/null
real	0m0.011s
user	0m0.001s
sys	0m0.003s

$ time ./read_3_fgetc sample_100.txt > /dev/null
real	0m0.008s
user	0m0.001s
sys	0m0.002s

$ time ./read_3_fgetc sample_1000000.txt > /dev/null
real	0m0.080s
user	0m0.074s
sys	0m0.004s

$ time ./read_3_fgetc sample_10000000.txt > /dev/null

real	0m0.692s
user	0m0.670s
sys	0m0.011s
\end{lstlisting}

\fbox{問題2-2}\\
NBUFが2048の時(ソースコード4)の実行．

\begin{lstlisting}[basicstyle=\footnotesize,caption={time\_read\_2\_2048byte\_prob2\_2}, label=time2048]
$ time ./read_2_2048byte_prob2_2 sample_10.txt > /dev/null
real	0m0.006s
user	0m0.001s
sys	0m0.002s

$ time ./read_2_2048byte_prob2_2 sample_100.txt > /dev/null
real	0m0.006s
user	0m0.001s
sys	0m0.002s

$ time ./read_2_2048byte_prob2_2 sample_1000000.txt > /dev/null
real	0m0.006s
user	0m0.002s
sys	0m0.002s

$ time ./read_2_2048byte_prob2_2 sample_10000000.txt > /dev/null
real	0m0.014s
user	0m0.002s
sys	0m0.007s
\end{lstlisting}

\fbox{問題2-3}\\
ソースコード2をfgets(3)，print(3)を用いて書き直したコード(ソースコード5)の実行．
\begin{lstlisting}[basicstyle=\footnotesize, caption={time\_read\_3\_fgets\_prob2\_3}, label=timefgets]
$ time ./read_3_fgets_prob2_3 sample_10.txt > /dev/null
real	0m0.005s
user	0m0.001s
sys	0m0.002s

$ time ./read_3_fgets_prob2_3 sample_100.txt > /dev/null
real	0m0.005s
user	0m0.001s
sys	0m0.002s

$ time ./read_3_fgets_prob2_3 sample_1000000.txt > /dev/null
real	0m0.027s
user	0m0.020s
sys	0m0.002s

$ time ./read_3_fgets_prob2_3 sample_10000000.txt > /dev/null
real	0m0.169s
user	0m0.154s
sys	0m0.007s
\end{lstlisting}
\vspace{1zh}

ファイルの文字の数が多いほど処理時間が掛かることが分かった．また，システムコールを用いたcatコマンドよりもライブラリ関数を用いたcatコマンドの方が，処理速度が速かった．\\
\fbox{問題2-4}\\
以下のようにstrace関数を用いてシステムコールがどのように呼ばれているかを確認した．

\begin{table}[H]
  \begin{center}
    \begin{tabular}{|p{150mm}|}
      \hline
      \verb|$|　strace -e trace=open,read,write,close                           \\
      \verb|>|  ./(file name) sample\_10.txt  \verb|>|  /dev/null \\
      \hline
    \end{tabular}
  \end{center}
\end{table}
\vspace{-2zh}
結果を以下に示す．

\begin{lstlisting}[basicstyle=\footnotesize,caption={strace\_read\_2\_1byte}, label=strace1byte]
$ strace -e trace=open,read,write,close 
./read_2_1byte sample_10.txt > /dev/null 
open("/etc/ld.so.cache", O_RDONLY)      = 3
close(3)                                = 0
open("/lib/libc.so.6", O_RDONLY)        = 3
read(3, "\177ELF\1\1\1\3\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200~\230\0004\0\0\0"..., 512) = 512
close(3)                                = 0
open("sample_10.txt", O_RDONLY)         = 3
read(3, "a", 1)                         = 1
write(1, "a", 1)                        = 1
read(3, "a", 1)                         = 1
write(1, "a", 1)                        = 1
read(3, "a", 1)                         = 1
write(1, "a", 1)                        = 1
read(3, "a", 1)                         = 1
write(1, "a", 1)                        = 1
read(3, "a", 1)                         = 1
write(1, "a", 1)                        = 1
read(3, "a", 1)                         = 1
write(1, "a", 1)                        = 1
read(3, "a", 1)                         = 1
write(1, "a", 1)                        = 1
read(3, "a", 1)                         = 1
write(1, "a", 1)                        = 1
read(3, "a", 1)                         = 1
write(1, "a", 1)                        = 1
read(3, "\n", 1)                        = 1
write(1, "\n", 1)                       = 1
read(3, "", 1)                          = 0
close(3)                                = 0
+++ exited with 0 +++

	\end{lstlisting}

\begin{lstlisting}[basicstyle=\footnotesize, caption={strace\_read\_3\_fgetc}, label=stracefgetc]
$ strace -e trace=open,read,write,close 
./read_3_fgetc sample_10.txt > /dev/null 
open("/etc/ld.so.cache", O_RDONLY)      = 3
close(3)                                = 0
open("/lib/libc.so.6", O_RDONLY)        = 3
read(3, "\177ELF\1\1\1\3\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200~\230\0004\0\0\0"..., 512) = 512
close(3)                                = 0
open("sample_10.txt", O_RDONLY)         = 3
read(3, "a", 1)                         = 1
write(1, "a", 1)                        = 1
read(3, "a", 1)                         = 1
write(1, "a", 1)                        = 1
read(3, "a", 1)                         = 1
write(1, "a", 1)                        = 1
read(3, "a", 1)                         = 1
write(1, "a", 1)                        = 1
read(3, "a", 1)                         = 1
write(1, "a", 1)                        = 1
read(3, "a", 1)                         = 1
write(1, "a", 1)                        = 1
read(3, "a", 1)                         = 1
write(1, "a", 1)                        = 1
read(3, "a", 1)                         = 1
write(1, "a", 1)                        = 1
read(3, "a", 1)                         = 1
write(1, "a", 1)                        = 1
read(3, "\n", 1)                        = 1
write(1, "\n", 1)                       = 1
read(3, "", 1)                          = 0
close(3)                                = 0
+++ exited with 0 +++
        \end{lstlisting}

\begin{lstlisting}[basicstyle=\footnotesize, caption={strace\_read\_2\_2048byte\_prob2\_2}, label=strace2048]
$ strace -e trace=open,read,write,close 
./read_2_2048bytes_prob2_2 sample_10.txt > /dev/null 
open("/etc/ld.so.cache", O_RDONLY)      = 3
close(3)                                = 0
open("/lib/libc.so.6", O_RDONLY)        = 3
read(3, "\177ELF\1\1\1\3\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200~\230\0004\0\0\0"..., 512) = 512
close(3)                                = 0
open("sample_10.txt", O_RDONLY)         = 3
read(3, "aaaaaaaaa\n", 2048)            = 10
write(1, "aaaaaaaaa\n", 10)             = 10
read(3, "", 2048)                       = 0
close(3)                                = 0
+++ exited with 0 +++
\end{lstlisting}


%%見直し
\subsubsection{演習4}
\fbox{問題4-4}\\
子プロセスでexitを使わない場合，wait関数のstatusはどのような値を返すかを調べた．以下は後者の子プロセスでexitを使わないコードを作成した時の実行結果である．
\begin{lstlisting}[basicstyle=\footnotesize, caption={prob4-4}, label=waitparent]
$ ./prob4-4
child finish
status No. = 0
parent finish
\end{lstlisting}

%%
\section{考察}
\subsection*{\fbox{レポート課題2}　演習2-1から2-4の結果をまとめて考察せよ。}
time関数によって上から順にプログラムの呼び出しから処理終了までにかかった時間、プログラムの処理時間、システムコールの処理時間を示されたが、ソースコード21〜24から分かる通り処理時間はテキストファイルの大きさに比例して長くなっていることがわかる。また、fgetc(3)を使用した時よりもfgets(3)を使用した時の方が処理時間が長くなっていることがわかる。これはNBUFを2048と定義しているのに対し、テキストファイルには1行10文字しか書かれていないため、そのぶんだけ後者では無駄な処理時間が発生していると考えられる。また、当然であるが1byteずつのみ読み込んだ場合よりも2048byteずつ読み込んでいるシステムコール関数の方が一度に複数もじ読み込めるため処理時間は短くなっている。

\subsection*{\fbox{レポート課題3}　演習4-4の結果をまとめて考察せよ。}
実験結果のソースコード28にあるようにstatusの値には0が返っていることがわかる。おそらくこれは子プロセスでexitを書かなかった場合、もし正常終了したならばその意味を持つ0を返すようになっていると考えられる。そのため今回は子プロセスが正常に終了しwait関数は正常に実行されたためにその0がstatusとして返ってきたと考えられる。

\subsection*{\fbox{レポート課題4}　演習5-6までに作成したプログラムにリダイレクションの機能を追加せよ}
以下に作成したコードを示す。

\begin{lstlisting}[basicstyle=\footnotesize, caption={shell5-7.c}, label=kadai5-7]
#include <stdio.h>
#include<stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <dirent.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>

#define MAX_LINE_IN 1000
#define MAX_ARGS 30

int main(int argc,char *argv[])
{
  int pid,status;
  char line_in[MAX_LINE_IN];
  char *args[MAX_ARGS];
  int nargs;
  
  for(;;){
    printf("> ");
    if(fgets(line_in,MAX_LINE_IN,stdin)==NULL)exit(0);
    line_in[strlen(line_in)-1]='\0';
    char *token = strtok(line_in," ");
    
    //torknize
    nargs = 0;
    args[nargs++] = token;
    
    while(token!=NULL){
      token = strtok(NULL," ");
      if(token!=NULL){
		args[nargs++] = token;
      }
    }
    
    args[nargs] = NULL;//end
    
    //exec
    if(fork()==0){
      if((strcmp(args[1],">")==0)){
	int fd;
	if(args[2]!=NULL){
	  fd=open(args[2],O_WRONLY|O_CREAT,0664);
	  close(1);
	  dup(fd);
	  execlp(args[0],args[0],(char *)0);
	  exit(0);
	}
      }
      
      execv(args[0],args);
      printf("command not found\n");
      exit(1);
    }
    
    else{wait(&status);
    }
  }
  
  return 0;
}
\end{lstlisting}

\vspace{2zh}
リダイレクションの機能は上記のコードの42行目から書いてある。strcmpを用いて第1引数に"\verb|>|"が入力された場合に条件文の中に入りファイルディスクリプタを用いて標準出力に出力されるものをファイルに書き込むようにしている。

\section{結論・まとめ}
今回の実験を通してシステムコールやライブラリ関数の意味、用途を理解し、実際にC言語とともに用いてそれらを実装かつ実行することができた。また、シェルをC言語を用いて自作し、それによってシェルそのものの仕組みがいかなるものであるかを学ぶことができた。

\section{感想}
今回の実験はプログラミング的な内容においてもかなりPCの中枢にあるものであったためにC言語を用いたとはいえ、その意味を理解するのが難しく大変だった。内容の理解は予習・復習から大きく影響を受けているので、今後の実験はさらに予習復習をしっかりして挑みたいと思う。

\begin{thebibliography}{99}
  \bibitem{getsdanger}
  6-2. バッファオーバーラン その2「危険な関数たち」 - IPA｜https://www.ipa.go.jp/security/awareness/vendor/programmingv1/b06\_02.html｜	最終閲覧日：2017/6/4
  \bibitem{wow}
  c言語で簡単なシェルプログラムを作ってみた - tsurutanのつぶやき｜http://www.tsurutan.com/entry/2015/06/11/113630｜最終閲覧日：2017/6/4
\end{thebibliography}


\end{document}
